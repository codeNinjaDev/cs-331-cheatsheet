\documentclass{article}
\usepackage[utf8]{inputenc}

% maxamize space on paper
\usepackage[nomarginpar, margin=.1in]{geometry}
\usepackage{sectsty}

\sectionfont{\fontsize{9}{9}\selectfont}
\subsectionfont{\fontsize{9}{9}\selectfont}
\usepackage[compact]{titlesec}
\usepackage{enumitem}
\setlist[1]{itemsep=-5pt}
\setlist[2]{itemsep=-5pt}
\begin{document}
% -Solving recurrences

% -Merge Sort

% -closest pair

% Dynamic Programming

% - Weighted Interval Scheduling

% - Memoization

% - Subset Sums and Knapsacks

% - Sequence Alignment

% - Bellman-Ford Algorithm

% Network Flow

% - Maximum Flow Problem and the Ford-Fulkerson Algorithm.

% - Maximum Flow and Minimum Cut in a Network
\section{Solving Recurrences}
\subsection{via Unrolling}
To solve the recurrence via unrolling, you plot the values of the size of the problem and
the time taken to solve the problem in the table to find a generalized equation. For example,
merge sort's recurrence is: $T(n) = 2T(\frac{n}{2}) + n$ where $T(1) = 0$

\begin{center}
    \begin{tabular}{c c c}
        \underline{Level} & \underline{Size} & \underline{Time} \\
        0 & $n$ & $n = n$ \\
        1 & $n/2$ & $2(n/2) = n$ \\
        2 & $n/4$ & $4(n/4) = n$ \\
        k & $n/2^k$ & $2^k(n/2^k) = n$ \\
    \end{tabular}
\end{center}

You can then multiply your generalized time function (in this case just $n$) by the number of levels
to get the runtime. You can get the levels by solving the following for $k$: $1 = n/2^k$ where $1$ represents the value of $n$
at the base case and where the righthand side is the generalized function found in the size column.
In this case, $k \approx log(n)$, therefore the runtime is $O(n*log(n))$


\subsection{via Master Theorem}
In order to use the master theorem to solve a problem, the recurrence must be of the form:
$T(n) = aT(\frac{n}{b})+f(n)$
There are three cases for the master theorem, in each case it must be \textbf{polynominally} larger/smaller for the case to apply.

\begin{enumerate}
    \item (Leaf-Heavy) if $f(n) < n^{log_b(a)}$, then  $T(n) = O(n^{log_b(a)})$
    \item if $f(n) = n^{log_b(a)}$, then $T(n) = O(n^{log_b(a)}log(n))$
    \item (Root-Heavy) if $f(n) > n^{log_b(a)}$, then $T(n) = O(f(n))$
\end{enumerate}

\section{Merge Sort}
\section{Closest Pair}
\section{Dynamic Programming}
\subsection{Weighted Interval Scheduling}
\subsection{Memoization}
\subsection{Subset Sums and Knapsacks}
\subsection{Sequence Alignment}
\subsection{Bellman-Ford Algorithm}
\section{Network Flow}
\subsection{Maximum Flow Problem and Ford-Fulkerson Algorithm}
\subsection{Maximum Flow and Minimum Cut in a Network}

\end{document}

